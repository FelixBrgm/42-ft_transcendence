mod queue;
use self::queue::queue;

#[tokio::main]
async fn main() {
    queue().await;
}
use futures_util::{SinkExt, StreamExt};
use tokio::{
    net::TcpStream,
    sync::mpsc::{self, Receiver, Sender},
};
use tokio_tungstenite::WebSocketStream;
use tungstenite::Message;

pub(crate) fn bridge(
    socket: WebSocketStream<TcpStream>,
) -> (Sender<String>, Receiver<String>, Receiver<()>) {
    let (mscp_to_socket_sender, mut mscp_to_socket_receiver) = mpsc::channel::<String>(1);
    let (socket_to_mscp_sender, socket_to_mscp_receiver) = mpsc::channel::<String>(1);
    let (disconnect_sender, disconnect_receiver) = mpsc::channel::<()>(1);

    let (mut write, mut read) = socket.split();

    tokio::spawn(async move {
        loop {
            match read.next().await {
                Some(msg) => {
                    if let Ok(msg) = msg {
                        if let Ok(msg) = msg.into_text() {
                            let _ = socket_to_mscp_sender.send(msg).await;
                        };
                    }
                }
                None => {
                    let _ = disconnect_sender.send(()).await;
                    break;
                } // Socket_to_mpsc_sender is dropped here that causes the channel to return None at the receiver
            }
        }
    });
    tokio::spawn(async move {
        loop {
            match mscp_to_socket_receiver.recv().await {
                Some(msg) => {
                    let _ = write.send(Message::Text(msg + "\n")).await;
                }
                None => {
                    let _ = write.close().await;
                    break;
                }
            }
        }
    });

    return (
        mscp_to_socket_sender,
        socket_to_mscp_receiver,
        disconnect_receiver,
    );
}
mod ball;
mod game_config;
mod player;
mod utils;

pub use self::ball::Ball;
pub use self::game_config::GameConfig;
pub use self::player::Player;
use utils::get_ms;

use std::time::Duration;

pub struct Game {
    players: [Player; 2],
    ball: Ball,
    config: GameConfig,
    last_tick_time: u128,
    time_since_last_tick: u128,
}

impl Game {
    pub fn new(players: [Player; 2]) -> Self {
        let ball = Ball::new();
        let config = GameConfig::new();
        let last_tick_time = get_ms();
        let time_since_last_tick = 0;
        Game {
            players,
            ball,
            config,
            last_tick_time,
            time_since_last_tick,
        }
    }

    pub async fn start(mut self) {
        loop {
            self.wait_till_next_tick().await;
            if self.has_player_disconnected() {
                return;
            }
            self.tick().await;
        }
    }

    async fn tick(&mut self) {
        // Get last input
        for i in 0..2 {
            if let Ok(last_input) = self.players[i].receiver.try_recv() {
                if let Some(c) = last_input.chars().last() {
                    self.players[i].last_input = c;
                }
            }
        }

        self.update_player_position();

        self.send_pos().await;
    }
    // Pos
    fn update_player_position(&mut self) {
        let length_traveled: u16 = (self.time_since_last_tick * self.config.length_per_ms) as u16;

        for i in 0..2 {
            let player = &mut self.players[i];

            match player.last_input {
                'd' => {
                    if player.position > length_traveled {
                        player.position -= length_traveled;
                    } else {
                        player.position = 0;
                    }
                }
                'u' => {
                    player.position += length_traveled;
                    if player.position > self.config.length - self.config.paddle_length {
                        player.position = self.config.length - self.config.paddle_length;
                    }
                }
                _ => {}
            }
        }
    }

    // Utils
    async fn send_pos(&mut self) {
        let msg = format!(
            "POS{:05}{:05}{:05}{:05}",
            self.players[0].position, self.players[1].position, self.ball.x, self.ball.y
        );
        self.send_msg_to_players(msg.to_string()).await;
    }

    async fn send_msg_to_players(&mut self, msg: String) {
        for i in 0..2 {
            let _ = self.players[i].sender.send(msg.to_owned()).await;
        }
    }

    async fn wait_till_next_tick(&mut self) {
        loop {
            // This is so that it always takes 1ms steps minimum
            if get_ms() <= self.last_tick_time {
                std::thread::sleep(Duration::from_millis(1));
                continue;
            }

            self.time_since_last_tick = get_ms() - self.last_tick_time;

            if self.time_since_last_tick > self.config.min_time_per_tick_ms {
                self.last_tick_time = self.last_tick_time + self.time_since_last_tick;
                break;
            }

            std::thread::sleep(Duration::from_millis(
                ((self.config.min_time_per_tick_ms / 3) + 1) as u64,
            ));
        }
    }

    fn has_player_disconnected(&mut self) -> bool {
        for i in 0..2 {
            if self.players[i].is_disconnected() {
                return true;
            }
        }
        return false;
    }
}
pub struct GameConfig {
    pub min_time_per_tick_ms: u128,
    pub length_per_ms: u128,
    pub length: u16,
    pub width: u16,
    pub paddle_length: u16,
}
impl GameConfig {
    pub fn new() -> Self {
        let min_time_per_tick_ms: u128 = 50;
        let length_per_ms: u128 = 1;
        let ball_speed_div: u16 = 2;
        let length: u16 = 10000;
        let width: u16 = 10000;
        let paddle_length: u16 = 2000;

        GameConfig {
            min_time_per_tick_ms,
            length_per_ms,
            length,
            width,
            paddle_length,
        }
    }
}
pub struct Ball {
    pub x: u16,
    pub y: u16,
}
impl Ball {
    pub fn new() -> Self {
        Ball { x: 0, y: 0 }
    }
}
use tokio::sync::mpsc::{Receiver, Sender};

pub struct Player {
    pub sender: Sender<String>,
    pub receiver: Receiver<String>,
    disconnect: Receiver<()>,
    pub position: u16,
    pub last_input: char,
}
impl Player {
    pub fn new(
        sender: Sender<String>,
        receiver: Receiver<String>,
        disconnect: Receiver<()>,
    ) -> Self {
        let position = 0;
        let last_input = 'n';
        Player {
            sender,
            receiver,
            disconnect,
            position,
            last_input,
        }
    }

    pub fn is_disconnected(&mut self) -> bool {
        if let Ok(_) = self.disconnect.try_recv() {
            return true;
        }
        return false;
    }
}
use std::time::{SystemTime, UNIX_EPOCH};

pub(crate) fn get_ms() -> u128 {
    let now = SystemTime::now();
    let duration = now
        .duration_since(UNIX_EPOCH)
        .expect("Failed to calculate duration");
    let milliseconds = duration.as_secs() as u128 * 1000 + u128::from(duration.subsec_millis());
    milliseconds
}
use tokio::net::TcpListener;

mod bridge;
mod game;

use self::game::*;

use bridge::bridge;

pub(crate) async fn queue() {
    let listener = TcpListener::bind("127.0.0.1:4242").await.unwrap();

    let mut queue: Vec<Player> = Vec::<Player>::new();

    loop {
        let (socket, _) = listener.accept().await.unwrap();
        let socket = tokio_tungstenite::accept_async(socket).await.unwrap();

        let (sender, receiver, disconnect) = bridge(socket);

        queue.push(Player::new(sender, receiver, disconnect));

        remove_disconnected_sockets(&mut queue);

        if queue.len() >= 2 {
            let p1 = queue.remove(0);
            let p2 = queue.remove(0);
            let game = Game::new([p1, p2]);

            tokio::spawn(async move {
                println!("Game start!");
                game.start().await;
                println!("Game ended!");
            });
        }
    }
}

fn remove_disconnected_sockets(queue: &mut Vec<Player>) {
    let mut i = 0;
    while i < queue.len() {
        if queue[i].is_disconnected() {
            queue.remove(i);
        } else {
            i += 1;
        }
    }
}
